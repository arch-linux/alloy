import type { GuiProject, GuiElement } from "../../lib/types";

interface Props {
  project: GuiProject;
  modId: string;
}

export default function GuiCodePreview({ project, modId }: Props) {
  const className = toPascalCase(project.name) + "Screen";
  const handlerClass = toPascalCase(project.name) + "ScreenHandler";

  const code = generateScreenClass(project, modId, className, handlerClass);

  return (
    <div className="flex-1 overflow-auto bg-obsidian-950 p-4">
      <div className="mb-3 flex items-center justify-between">
        <div className="text-[11px] text-stone-400">
          Generated: <span className="text-ember font-mono">{className}.java</span>
        </div>
        <button
          onClick={() => navigator.clipboard.writeText(code)}
          className="text-[10px] text-stone-500 hover:text-ember px-2 py-1 rounded hover:bg-obsidian-800 transition-colors cursor-pointer"
        >
          Copy
        </button>
      </div>
      <pre className="text-[11px] font-mono text-stone-300 leading-relaxed whitespace-pre-wrap break-words">
        {code}
      </pre>
    </div>
  );
}

function generateScreenClass(
  project: GuiProject,
  modId: string,
  className: string,
  handlerClass: string,
): string {
  const slots = project.elements.filter((e) => e.type === "slot");
  const progressBars = project.elements.filter((e) => e.type === "progress_bar");
  const energyBars = project.elements.filter((e) => e.type === "energy_bar");
  const fluidTanks = project.elements.filter((e) => e.type === "fluid_tank");
  const buttons = project.elements.filter((e) => e.type === "button");
  const labels = project.elements.filter((e) => e.type === "label");

  let code = `package ${modId}.client.gui;

import net.alloymc.api.client.gui.Screen;
import net.alloymc.api.client.gui.ScreenHandler;
import net.alloymc.api.client.gui.widget.*;
import net.alloymc.api.util.ResourceLocation;
import net.alloymc.api.util.Text;

/**
 * Auto-generated GUI screen: ${project.name}
 * Canvas size: ${project.width}x${project.height}
 * Generated by Alloy IDE
 */
public class ${className} extends Screen<${handlerClass}> {

    private static final ResourceLocation TEXTURE =
        new ResourceLocation("${modId}", "textures/gui/${project.name}.png");

    private static final int GUI_WIDTH = ${project.width};
    private static final int GUI_HEIGHT = ${project.height};

`;

  // Field declarations for dynamic elements
  if (progressBars.length > 0) {
    progressBars.forEach((pb, i) => {
      code += `    private ProgressWidget progress${i};\n`;
    });
    code += "\n";
  }
  if (energyBars.length > 0) {
    energyBars.forEach((eb, i) => {
      code += `    private EnergyBarWidget energy${i};\n`;
    });
    code += "\n";
  }
  if (fluidTanks.length > 0) {
    fluidTanks.forEach((ft, i) => {
      code += `    private FluidTankWidget fluid${i};\n`;
    });
    code += "\n";
  }

  // Constructor
  code += `    public ${className}(${handlerClass} handler, Text title) {
        super(handler, title);
        this.guiWidth = GUI_WIDTH;
        this.guiHeight = GUI_HEIGHT;
    }

    @Override
    protected void init() {
        super.init();
        int x = (this.width - GUI_WIDTH) / 2;
        int y = (this.height - GUI_HEIGHT) / 2;

`;

  // Slot registration
  if (slots.length > 0) {
    code += `        // Inventory slots\n`;
    slots.forEach((slot) => {
      const slotId = slot.properties.slot_id ?? 0;
      code += `        addSlot(new SlotWidget(handler.getInventory(), ${slotId}, x + ${slot.x}, y + ${slot.y}));\n`;
    });
    code += "\n";
  }

  // Progress bars
  if (progressBars.length > 0) {
    code += `        // Progress indicators\n`;
    progressBars.forEach((pb, i) => {
      code += `        progress${i} = addWidget(new ProgressWidget(x + ${pb.x}, y + ${pb.y}, ${pb.width}, ${pb.height}, ProgressWidget.Direction.${((pb.properties.direction as string) || "right").toUpperCase()}));\n`;
    });
    code += "\n";
  }

  // Energy bars
  if (energyBars.length > 0) {
    code += `        // Energy displays\n`;
    energyBars.forEach((eb, i) => {
      code += `        energy${i} = addWidget(new EnergyBarWidget(x + ${eb.x}, y + ${eb.y}, ${eb.width}, ${eb.height}, ${eb.properties.max_value ?? 10000}));\n`;
    });
    code += "\n";
  }

  // Fluid tanks
  if (fluidTanks.length > 0) {
    code += `        // Fluid tanks\n`;
    fluidTanks.forEach((ft, i) => {
      code += `        fluid${i} = addWidget(new FluidTankWidget(x + ${ft.x}, y + ${ft.y}, ${ft.width}, ${ft.height}, ${ft.properties.max_mb ?? 16000}));\n`;
    });
    code += "\n";
  }

  // Buttons
  if (buttons.length > 0) {
    code += `        // Buttons\n`;
    buttons.forEach((btn, i) => {
      code += `        addWidget(new ButtonWidget(x + ${btn.x}, y + ${btn.y}, ${btn.width}, ${btn.height}, Text.literal("${btn.label || ""}"), button -> {\n`;
      code += `            // TODO: Handle button ${i} click\n`;
      code += `        }));\n`;
    });
    code += "\n";
  }

  code += `    }

    @Override
    protected void drawBackground(DrawContext context, float delta, int mouseX, int mouseY) {
        context.drawTexture(TEXTURE, getGuiLeft(), getGuiTop(), 0, 0, GUI_WIDTH, GUI_HEIGHT);
    }

    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        renderBackground(context);
        super.render(context, mouseX, mouseY, delta);
`;

  // Labels drawn in render
  if (labels.length > 0) {
    code += `\n        // Text labels\n`;
    labels.forEach((lbl) => {
      const color = lbl.properties.color || "#f0f0f4";
      const hexColor = "0x" + (color as string).replace("#", "").toUpperCase();
      const align = lbl.properties.align || "left";
      if (align === "center") {
        code += `        context.drawCenteredText(this.textRenderer, "${lbl.label || ""}", getGuiLeft() + ${lbl.x} + ${Math.round(lbl.width / 2)}, getGuiTop() + ${lbl.y}, ${hexColor});\n`;
      } else {
        code += `        context.drawText(this.textRenderer, "${lbl.label || ""}", getGuiLeft() + ${lbl.x}, getGuiTop() + ${lbl.y}, ${hexColor}, false);\n`;
      }
    });
  }

  code += `\n        drawMouseoverTooltip(context, mouseX, mouseY);
    }
`;

  // Update method for dynamic widgets
  if (progressBars.length > 0 || energyBars.length > 0 || fluidTanks.length > 0) {
    code += `
    @Override
    protected void handlerTick() {
`;
    progressBars.forEach((_, i) => {
      code += `        progress${i}.setProgress(handler.getProgress${i > 0 ? i : ""}());\n`;
    });
    energyBars.forEach((_, i) => {
      code += `        energy${i}.setEnergy(handler.getEnergy${i > 0 ? i : ""}());\n`;
    });
    fluidTanks.forEach((_, i) => {
      code += `        fluid${i}.setFluid(handler.getFluid${i > 0 ? i : ""}());\n`;
    });
    code += `    }
`;
  }

  code += `}\n`;

  return code;
}

function toPascalCase(s: string): string {
  return s
    .split(/[-_\s]+/)
    .filter(Boolean)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
    .join("");
}
