import type { AnimationProject, AnimationTrack, EasingType } from "../../lib/types";

interface Props {
  project: AnimationProject;
}

export default function AnimCodePreview({ project }: Props) {
  const className = toPascalCase(project.name) + "Animation";
  const code = generateAnimationCode(project, className);

  return (
    <div className="flex-1 overflow-auto bg-obsidian-950 p-4">
      <div className="mb-3 flex items-center justify-between">
        <div className="text-[11px] text-stone-400">
          Generated: <span className="text-ember font-mono">{className}.java</span>
        </div>
        <button
          onClick={() => navigator.clipboard.writeText(code)}
          className="text-[10px] text-stone-500 hover:text-ember px-2 py-1 rounded hover:bg-obsidian-800 transition-colors cursor-pointer"
        >
          Copy
        </button>
      </div>
      <pre className="text-[11px] font-mono text-stone-300 leading-relaxed whitespace-pre-wrap break-words">
        {code}
      </pre>
    </div>
  );
}

function generateAnimationCode(project: AnimationProject, className: string): string {
  const tracks = project.tracks;

  let code = `package client.animation;

import net.alloymc.api.client.animation.Animation;
import net.alloymc.api.client.animation.AnimationTrack;
import net.alloymc.api.client.animation.Keyframe;
import net.alloymc.api.client.animation.Easing;

/**
 * Auto-generated animation: ${project.name}
 * Duration: ${project.duration_ticks} ticks (${(project.duration_ticks / 20).toFixed(1)}s @ 20 TPS)
 * Tracks: ${tracks.length}
 * Generated by Alloy IDE
 */
public class ${className} extends Animation {

    public ${className}() {
        super(${project.duration_ticks});
`;

  if (project.sprite_sheet) {
    code += `\n        // Sprite sheet configuration\n`;
    code += `        setSpriteSheet("${project.sprite_sheet}");\n`;
    if (project.frame_width) code += `        setFrameWidth(${project.frame_width});\n`;
    if (project.frame_height) code += `        setFrameHeight(${project.frame_height});\n`;
  }

  code += "\n";

  tracks.forEach((track, i) => {
    const varName = `track${i}`;
    code += `        // Track: ${track.property}${track.target_element ? ` (target: ${track.target_element})` : ""}\n`;
    code += `        AnimationTrack ${varName} = addTrack(AnimationTrack.Property.${track.property.toUpperCase()});\n`;

    if (track.target_element) {
      code += `        ${varName}.setTarget("${track.target_element}");\n`;
    }

    track.keyframes.forEach((kf) => {
      const easingStr = easingToJava(kf.easing);
      code += `        ${varName}.addKeyframe(new Keyframe(${kf.tick}, ${formatValue(kf.value)}, ${easingStr}));\n`;
    });

    code += "\n";
  });

  code += `    }

    /**
     * Call this method each tick to advance the animation.
     * Typically called from your renderer or block entity tick.
     *
     * Example usage:
     *   private final ${className} animation = new ${className}();
     *
     *   // In your tick method:
     *   animation.tick();
     *
     *   // In your render method:
     *   float uvX = animation.getValue(AnimationTrack.Property.UV_OFFSET_X);
     */
`;

  // Generate convenience getters for common use cases
  const propertyMethods = new Set(tracks.map((t) => t.property));

  for (const prop of propertyMethods) {
    const methodName = "get" + toPascalCase(prop);
    code += `    public float ${methodName}() {\n`;
    code += `        return getValue(AnimationTrack.Property.${prop.toUpperCase()});\n`;
    code += `    }\n\n`;
  }

  code += `}\n`;

  return code;
}

function easingToJava(easing: EasingType): string {
  switch (easing) {
    case "linear": return "Easing.LINEAR";
    case "ease-in": return "Easing.EASE_IN";
    case "ease-out": return "Easing.EASE_OUT";
    case "ease-in-out": return "Easing.EASE_IN_OUT";
    case "cubic-bezier": return "Easing.CUBIC_BEZIER";
    default: return "Easing.LINEAR";
  }
}

function formatValue(v: number): string {
  if (Number.isInteger(v)) return v + ".0f";
  return v + "f";
}

function toPascalCase(s: string): string {
  return s
    .split(/[-_\s]+/)
    .filter(Boolean)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
    .join("");
}
